{
  "global_guidelines": {
  "objective": "Generate formal and complete arc42-compliant architecture documentation for any type of software system, targeting both technical and non-technical stakeholders. The documentation must reflect the real implementation of the codebase and support validation by the development team.",
  "formatting": [
    "Use clear, structured, and formal English.",
    "Write in complete, well-formed paragraphs—avoid bullet points.",
    "Structure content using LaTeX sections, subsections, and tables where needed.",
    "Include diagrams (especially PlantUML) when describing structure, runtime behavior, or deployment.",
    "Avoid redundancy across sections; maintain coherence and logical flow.",
    "Ensure the LaTeX output compiles without additional packages"
  ],
  "commitment": [
    "Ensure full coverage of the arc42 template using insights derived from the actual source code.",
    "Write each section in a way that can be understood by both technical and non-technical stakeholders.",
    "Focus on clarity and correctness rather than theoretical completeness.",
    "Reflect practical decisions, actual dependencies, and architectural choices evident in the implementation."
  ],
  "code_analysis": "Examine every line of source code to understand functionality, components, responsibilities,  dependencies, deployment characteristics and interactions; make sure documentation reflects the real implementation.. Use this understanding to generate precise documentation aligned with the arc42 structure." 
},

  
  "latex_safety": [
    "The LaTeX preamble already contains \\\\usepackage{plantuml}. Do NOT add extra \\\\usepackage lines.",
    "Every diagram must be wrapped exactly as:",
    "\\\\begin{figure}[ht]",
    "\\\\centering",
    "\\\\begin{plantuml}",
    "@startuml",
    "<diagram content>",
    "@enduml",
    "\\\\end{plantuml}",
    "\\\\label{fig:<unique_label>}",
    "\\\\caption{<concise caption>}",
    "\\\\end{figure}",
    "When you reference the diagram in prose, use \\\\ref{fig:<unique_label>}.",
    "Escape all LaTeX special characters (e.g. underscore as \\\\_ , % as \\\\%).",
    "Avoid smart quotes and non-ASCII glyphs.",
    "Ensure all braces and \\\\begin/\\\\end pairs are balanced so the document compiles with pdflatex.",
	"Escape all special LaTeX characters — e.g. an underscore is \\_."
  ],

  "user_profile": {
    "role": "Software Architect",
    "preferred_language": "English",
    "output_format": "LaTeX",
    "writing_style": "Clear, professional, concise",
    "target_audience": "Developers and system integrators",
    "include": ["diagrams", "tables"],
    "diagram_format": "PlantUML"
  },

  
  "doc_template": {
  "1": {
    "title": "Introduction and Goals",
    "goal": "Explain main requirements, business goals, quality objectives, and stakeholder expectations that shape the architecture.",
    "format": {
      "text": {
        "description": "Overview of system goals and architectural drivers."
      }
    },
    "style": "High-level overview; avoid redundancy with other sections or external documents.",
    "subsections": {
      "1.1": {
        "title": "Requirements Overview",
        "goal": "Summarize key functional requirements and driving forces.",
        "format": {
          "text": {
            "description": "Short paragraph summarizing functional requirements and their context."
          },
          "table": {
            "columns": ["Use-case", "Summary"],
            "caption": "Main functional requirements"
          }
        },
        "style": "Brief and non-redundant;",
        "example": {
          "table": [
            ["Register user", "Allow new users to sign up via email and password."],
            ["Login", "Enable authentication and access to protected areas."]
          ]
        }
      },
      "1.2": {
        "title": "Quality Goals",
        "goal": "List 3–5 architecture-specific quality goals prioritized by stakeholder importance.",
        "format": {
          "text": {
            "description": "Paragraph explaining quality goals and their impact."
          },
          "table": {
            "columns": ["Quality Goal", "Priority", "Scenario"],
            "caption": "Architecture-specific quality objectives"
          }
        },
        "style": "Be specific and measurable. Avoid vague or generic statements.",
        "example": {
          "table": [
            ["Scalability", "High", "Support 10k concurrent users during peak load"],
            ["Availability", "Medium", "99.9% uptime with failover support"]
          ]
        }
      },
      "1.3": {
        "title": "Stakeholders",
        "goal": "Identify all stakeholders, their roles, and expectations relevant to the architecture.",
        "format": {
          "text": {
            "description": "Overview paragraph describing who the stakeholders are and why they matter."
          },
          "table": {
            "columns": ["Stakeholder", "Role", "Expectation"],
            "caption": "System stakeholders and their concerns"
          }
        },
        "style": "Ensure completeness; address all concerns that may affect architecture decisions.",
        "example": {
          "table": [
            ["Product Owner", "Business decision-maker", "Clear understanding of system capabilities"],
            ["QA Engineer", "Quality assurance", "Testable and maintainable architecture"]
          ]
        }
      }
    }
},
  "2": {
    "title": "Architecture Constraints",
    "goal": "Document technical, organizational, and legal constraints that limit architectural decisions.",
    "format": {
      "text": {
        "description": "Concise overview of relevant constraints affecting the architecture."
      },
      "table": {
        "columns": ["Constraint", "Type", "Explanation"],
        "caption": "Overview of architectural constraints"
      }
    },
    "style": "Categorize constraints clearly (technical, organizational, legal). Mark which ones are negotiable or fixed.",
    "example": {
      "table": [
        ["Technology stack", "Technical", "Must use Java and Spring Boot due to team expertise"],
        ["GDPR compliance", "Legal", "System must support user data deletion upon request"],
        ["Scrum process", "Organizational", "Development must follow two-week sprint cycles"]
      ]
    }
  },
  "3": {
    "title": "Context and Scope",
    "goal": "Describe the business and technical environment, define system boundaries, and identify external interfaces and communication partners.",
    "format": {
      "text": {
        "description": "Concise overview of the system context and boundaries."
      },
      "diagram": {
        "type": "Context Diagram",
        "description": "Black-box diagram showing external systems and users."
      },
      "table": {
        "columns": ["Partner", "Interface"],
        "caption": "Overview of system interfaces and communication partners"
      }
    },
    "style": "Separate business and technical aspects if needed. Highlight system boundaries clearly.",
    "subsections": {
      "3.1": {
        "title": "Business Context",
        "goal": "Clarify domain-specific interactions with communication partners, including exchanged data and business roles.",
        "format": {
          "text": {
            "description": "Short description of business partners and data exchange."
          },
          "diagram": {
            "type": "Domain Black-box Diagram",
            "description": "System as black box, showing business-related interfaces."
          },
          "table": {
            "columns": ["Partner", "Input", "Output"],
            "caption": "Business communication partners and their interactions"
          }
        },
        "style": "Focus on meaning of data and business relevance.",
        "example": {
          "table": [
            ["Customer", "Order request", "Order confirmation"],
            ["CRM System", "Customer data", "Account status"]
          ]
        }
      },
      "3.2": {
        "title": "Technical Context",
        "goal": "Detail the system’s external technical interfaces, communication protocols, and infrastructure dependencies.",
        "format": {
          "text": {
            "description": "Description of channels, hardware, and protocol mapping."
          },
          "diagram": {
            "type": "Deployment or Network Diagram",
            "description": "Shows technical links to external systems and components."
          },
          "table": {
            "columns": ["I/O Element", "Channel / Protocol"],
            "caption": "Mapping of inputs/outputs to technical interfaces"
          }
        },
        "style": "Expose infrastructure dependencies explicitly; focus on non-functional impact.",
        "example": {
          "table": [
            ["User credentials", "HTTPS POST"],
            ["Sensor data", "MQTT over TLS"]
          ]
        }
      }
    }
  },
  "4": {
    "title": "Solution Strategy",
    "goal": "Summarize the key technologies, architectural patterns, and strategic decisions that shape the solution.",
    "format": {
      "text": {
        "description": "Short explanation of critical architectural choices, technologies, and rationale."
      },
      "table": {
        "columns": ["Quality Goal", "Scenario", "Solution Approach"],
        "caption": "Mapping of solution strategies to quality goals and use cases"
      }
    },
    "style": "Tie every architectural choice to a stakeholder concern or quality goal. Prioritize clarity and traceability.",
    "example": {
      "table": [
        ["Scalability", "Support peak traffic of 10k users", "Use Kubernetes with auto-scaling", "See Section 7"],
        ["Security", "Protect sensitive user data", "Adopt OAuth2.0 and encrypt DB at rest", "See Appendix A"]
      ]
    }
  },
  "5": {
    "title": "Building Block View",
    "goal": "Describe the static decomposition of the system into modules, components, and subsystems across three levels of abstraction.",
    "format": {
      "text": {
        "description": "Responsibilities and purpose of each building block."
      },
      "diagram": {
        "type": "Hierarchy Diagram",
        "description": "Illustrates structural relationships among components."
      },
      "table": {
        "columns": ["Name", "Responsibility", "Description"],
        "caption": "Building blocks and their roles"
      }
    },
    "style": "Abstract from implementation details; use a consistent decomposition strategy.",
    "subsections": {
      "5.1": {
        "title": "Level 1 – White Box of the Overall System",
        "goal": "Show top-level decomposition and provide black-box descriptions of main system building blocks.",
        "format": {
          "text": {
            "description": "Explain rationale for decomposition and responsibilities of each top-level block."
          },
          "diagram": {
            "type": "Component / Container Diagram",
            "description": "Overview of high-level system blocks"
          },
          "table": {
            "columns": ["Component", "Responsibility", "Description"],
            "caption": "Black-box view of top-level components"
          }
        },
        "style": "Describe architectural rationale and component responsibilities clearly.",
        "example": {
          "table": [
            ["Web UI", "Handles user interaction", "Implemented as React SPA"],
            ["API Gateway", "Routes external requests", "Uses Spring Cloud Gateway"]
          ]
        }
      },
      "5.2": {
        "title": "Level 2 – Inner Structure of Level 1 Components",
        "goal": "Describe internal subcomponents of selected Level 1 blocks.",
        "format": {
          "text": {
            "description": "Explain how subcomponents are organized within a parent component."
          },
          "diagram": {
            "type": "Component Diagram per Block",
            "description": "Structure of subcomponents within a Level 1 component"
          },
          "table": {
            "columns": ["Method", "Input", "Output", "Responsibility"],
            "caption": "Interfaces and logic within components"
          }
        },
        "style": "Focus on meaningful component internals; avoid implementation noise.",
        "example": {
          "table": [
            ["processPayment", "PaymentRequest", "PaymentResult", "Validates and charges user"],
            ["sendEmail", "EmailTemplate", "Success/Failure", "Dispatches transactional email"]
          ]
        }
      },
      "5.3": {
        "title": "Level 3 – Fine-grained Details of Level 2 Components",
        "goal": "Describe detailed internals of specific Level 2 components, including key functions, data structures, and operations.",
        "optional": true,
        "format": {
          "text": {
            "description": "Describe low-level component logic, dependencies, and interactions."
          },
          "table": {
            "columns": ["Function", "Input", "Output", "Responsibility"],
            "caption": "Detailed view of critical functions"
          }
        },
        "style": "Use only when justified by architectural complexity.",
        "example": {
          "table": [
            ["hashPassword", "Plaintext password", "Hashed string", "Ensure secure password storage"],
            ["retryJob", "Job ID", "Retry status", "Handles automatic reprocessing"]
          ]
        }
      }
    }
  },
  "6": {
    "title": "Runtime View",
    "goal": "Describe key runtime scenarios that illustrate how building blocks interact to realize system functionality, including normal operation and error handling.",
    "format": {
      "text": {
        "description": "Short description of the purpose and context of each runtime scenario."
      },
      "steps": {
        "description": "Numbered list of interactions or steps in each scenario."
      },
      "diagram": {
        "type": "Sequence or Activity Diagram",
        "description": "Visual representation of interactions among components during scenario execution."
      }
    },
    "style": "Focus on architecturally significant scenarios. Use clear, concise steps. Avoid covering too many use cases.",
    "example": {
      "steps": [
        "1. User sends login request to the Web UI.",
        "2. Web UI forwards request to the Authentication Service.",
        "3. Authentication Service verifies credentials with the database.",
        "4. If valid, Authentication Service returns a token.",
        "5. Web UI stores token in session and redirects user to dashboard."
      ]
    }
  },
  "7": {
    "title": "Deployment View",
    "goal": "Describe the technical infrastructure where the system operates, including environments, hardware, network topology, and component-to-infrastructure mapping.",
    "format": {
      "text": {
        "description": "Overview of the deployment environment, including hardware, software, and environment-specific configurations."
      },
      "diagram": {
        "type": "UML Deployment Diagram",
        "description": "Illustrates nodes, channels, and component placements. Use nested diagrams for complex systems."
      },
      "list": {
        "items": "Deployment elements (nodes, environments, containers, channels)"
      }
    },
    "style": "Highlight differences between development, testing, and production environments. Emphasize component-to-infrastructure mapping for distributed systems.",
    "example": {
      "list": [
        "Web Server (Production) – hosts React frontend, located in AWS eu-west-1",
        "Application Server – runs backend services via Docker on Kubernetes",
        "Database Cluster – PostgreSQL with replication across two zones",
        "CI/CD Agent – executes deployment pipeline in staging environment"
      ]
    }
  },
  "8": {
    "title": "Cross-Cutting Concepts",
    "goal": "Describe concepts and architectural principles that apply across multiple components and layers of the system, ensuring consistency and overall quality.",
    "format": {
      "text": {
        "description": "Overview of each cross-cutting concept, its purpose, and its relevance to the system architecture."
      },
      "examples": {
        "description": "Illustrative examples or implementation guidelines for each concept."
      }
    },
    "style": "Clarify how each concept influences quality, development, and operational concerns. Use consistent structure across concepts.",
    "example": {
      "examples": [
        "**Security**: Use OAuth 2.0 for authentication, encrypt sensitive data at rest and in transit.",
        "**Logging**: All services must log requests and errors to a centralized ELK stack.",
        "**UX Consistency**: Follow the design system for all UI components, including color scheme and button behavior."
      ]
    }
  },
  "9": {
    "title": "Architecture Decisions",
    "goal": "Document and justify key architectural decisions, including their context, rationale, trade-offs, and consequences.",
    "format": {
      "text": {
        "description": "Brief overview of the architectural decision and its significance to the system."
      },
      "table": {
        "columns": ["Decision", "Context/Problem", "Rationale", "Trade-offs", "Consequences"],
        "caption": "Summary of key architectural decisions"
      }
    },
    "style": "Document only high-impact, high-risk, or costly decisions. Use ADR-style rationale. Avoid redundancy with Solution Strategy.",
    "example": {
      "table": [
        [
          "Use of RESTful API",
          "Need for stateless communication between frontend and backend",
          "REST is widely adopted, easy to integrate, and testable",
          "Less flexibility compared to GraphQL; potential for over-fetching",
          "Simplifies client-server interaction and aligns with existing tooling"
        ],
        [
          "PostgreSQL for persistence",
          "Requirement for relational data model and ACID compliance",
          "Proven reliability and strong community support",
          "Requires careful scaling for high-write workloads",
          "Stable and maintainable data layer with existing team expertise"
        ]
      ]
    }
  },
  "10": {
    "title": "Quality Requirements",
    "goal": "Capture measurable quality attributes, organize them by category, and provide traceable links to quality scenarios and goals.",
    "format": {
      "text": {
        "description": "Overview of the system’s quality requirements, including priorities and scope."
      },
      "tree": {
        "description": "Quality tree that organizes attributes into categories (e.g., performance, security)."
      },
      "table": {
        "columns": ["Category", "Quality", "Description", "Scenario ID"],
        "caption": "Detailed quality requirements with traceable scenarios"
      }
    },
    "style": "Be concrete and measurable. Connect each requirement to stakeholder needs or architecture drivers. Avoid generic quality goals.",
    "example": {
      "table": [
        ["Performance", "Response time", "System must respond within 200ms for 95% of requests", "Q1"],
        ["Security", "Authentication", "Only registered users can access internal APIs", "Q2"],
        ["Maintainability", "Code modularity", "Components must be independently testable", "Q3"]
      ]
    }
  },
  "11": {
    "title": "Risks and Technical Debt",
    "goal": "Identify and prioritize architectural risks and technical debt items, and define mitigation or resolution strategies.",
    "format": {
      "text": {
        "description": "Brief overview of the main risks and technical debt affecting the architecture."
      },
      "table": {
        "columns": ["ID", "Description", "Impact/Severity", "Mitigation/Resolution Plan", "Status"],
        "caption": "Prioritized list of risks and technical debt with mitigation strategies"
      }
    },
    "style": "Focus on high-impact or high-likelihood risks. Use clear and actionable mitigation steps. Keep status updated.",
    "example": {
      "table": [
        ["R1", "Tight coupling between services", "High", "Introduce API gateway and standardize interfaces", "Open"],
        ["D2", "Outdated dependency in authentication module", "Medium", "Upgrade to latest library version and add regression tests", "Resolved"]
      ]
    }
  },
  "12": {
    "title": "Glossary",
    "goal": "Define key terms and concepts used in the documentation to ensure a shared vocabulary among all stakeholders.",
    "format": {
      "text": {
        "description": "Introductory paragraph stating the purpose of the glossary."
      },
      "table": {
        "columns": ["Term", "Definition", "Translation (Optional)"],
        "caption": "Glossary of domain-specific and technical terms"
      }
    },
    "style": "Ensure clarity and avoid ambiguity. Keep definitions concise. Include translations if relevant for international teams.",
    "example": {
      "table": [
        ["API", "Set of functions allowing access to system features", "Interfaccia di Programmazione"],
        ["Latency", "Delay between request and response", "Latenza"],
        ["CI/CD", "Continuous Integration and Continuous Deployment pipeline", ""]
      ]
    }
  }
}

}
